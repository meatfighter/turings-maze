Turing’s Maze 

Abstract 

Turing’s Maze is a discrete-event simulation of a mouse on a two-dimensional square lattice of black, gray, red, and green cells. As the mouse interacts with cells through a very simple set of rules, behaviors emerge particularly suited for emulating Boolean circuits. Consequently, any algorithm can be implemented as a maze traversed by the mouse.  

This article describes the rules of Turing’s Maze. It explains how to build gates, combinational logic, and sequential logic. And it demonstrates the mouse’s ability to compute with an implementation of the Mandelbrot set algorithm. 

Description 

Each simulation state consists of the mouse on a cell, facing a cardinal direction (north, east, south, or west). Per the rules described below, the mouse’s direction and the color of the cell it is on may change. Then it steps in its direction to an adjacent cell, transitioning the simulation to the next state. 

The mouse can move to cells of any color except for gray, which act as the walls of the maze. Passages primarily consist of black cells. Red and green cells operate something like traffic lights. 

The mouse enters a maze from a lone black cell in some column of the southernmost row. It exits to a lone black cell in some column of the northernmost row: 

[ pic ] 

The mouse traverses the maze by following the right-hand rule. That is, from the start, it keeps its right hand (or paw) in contact with the wall to its right, and it follows the wall around corners as it advances. However, if it encounters a four-way intersection, it plows straight through:   

[ pic ] 

If the mouse lands on a green cell while facing east or west, it proceeds as if the cell were black: 

[ pic ]   

If the mouse lands on a red cell while facing east or west, it reverses direction: 

[ pic ] 

If the mouse lands on a red or a green cell while facing south, the cell changes to or remains as red, and the mouse turns north: 

[ pic ] 

Finally, if the mouse lands on a red or green cell while facing north, the cell changes to or remains as green, and the mouse turns south: 

[ pic ] 

Formal Definition 

The simulator repeatedly performs the following three steps until the mouse exits the maze. 

The simulator potentially changes the current tile color and the mouse’s direction in accordance with the following pseudocode. 

[ pseudocode ] 

The simulator inspects the tiles immediately left, in front of, and right of the mouse. It uses the table below, where 1 indicates a wall (a gray tile) and 0 indicates a passage (a nongray tile), to potentially change the mouse’s direction, maintaining consistent with the right-hand rule modified to ignore four-way intersections. 

[ table ] 

The simulator moves the mouse in its direction to an adjacent tile.  

Circuits 

In the circuits described below, the mouse propagates logic one as it travels. Paths of black tiles, separated by gray tiles, direct the mouse between components. They function as signal channels analogous to the wires of an electronic circuit. Four-way intersections act as non-connecting, crossing wires because the mouse disregards the right-hand rule when it encounters them. 

Red and green tiles operate as switching elements. Red represents a switch turned off, a disconnected channel that denies east-west signal propagation. And green represents a switch turned on, a connected channel that permits east-way signal propagation.  

The mouse turns a switch off by southwardly stepping onto a green tile. And it turns a switch on by northwardly stepping onto a red tile. 

Since a switch retains its state after the mouse steps away, red and green tiles also serve as data storage elements. In the circuits described below, red represents a stored logic zero, and green represents a stored logic one.  

Note: It is possible to build inverted circuits, where the mouse propagates logic zero, or dual-rail circuits, where the mouse propagates logic zero or logic one depending on which of two paths the mouse takes. 

Logic Gates 

Unlike traditional logic gates, logic gates implemented in Turing’s maze store input Boolean values. The values are all initialized to logic zero.  

When the mouse visits an input terminal--where “visit” means it enters and it subsequentially returns from the terminal--it toggles a stored value to logic one. After setting the inputs in this way, the mouse enters an express-and-reset terminal, which evaluates the logical operation for the stored inputs. If the result is logic one, the mouse visits the output terminal, expressing the result to whatever is wired to the gate. Finally, the mouse resets the stored values to logic zeros, and it returns from the express-and-reset terminal. 

To make this clear, the image below depicts an AND gate with the input terminals, the output terminal, and the express-and-reset terminal labeled.  

[ pic ] 

The red tiles store the input values. When the mouse visits an input terminal, it switches a red tile to a green tile. When the mouse enters the express-and-reset terminal, it visits the output terminal only if the mouse switched both red tiles to green. Then it flips any green tiles back to red. And it returns from the express-and-reset terminal.    

The following animated examples depict logic gates attached to test harnesses of the form: 

[ pic ] 

Each harness uses red and green tiles to control which input terminals the mouse visits, and a red tile to capture the result of the logical operation for the given input values. 

[ gates ] 

The XOR gate demonstrates combinational logic. It consists of a NAND gate and an OR gate whose outputs feed into an AND gate. The XOR’s express-and-reset terminal directs the mouse to the NAND and OR gate’s express-and-reset terminals prior to the AND’s express-and-reset terminal, ensuring the logical operations are performed in the correct sequence. 

Like XOR, XNOR demonstrates combinational logic. It consists of a NOR gate and an AND gate whose outputs feed into an OR gate. As with XOR, XNOR’s express-and-reset terminal directs the mouse to evaluate the logical operations in the proper order. 

A single red or green tile can function as a transmission gate: 

[ pic ] 

The image below depicts part of the circuit that computes the Mandelbrot set. It shows stacks of transmission gates with common control lines that connect or disconnect devices to a 9-bit bus. 

[ pic ] 

A 1-to-2 demultiplexer steers the mouse from a data input terminal to one of two output terminals: 

[ pic ] 

Here are test harnesses exercising all possible input values: 

[ pic ] 

The Mandelbrot set circuit employs a 1-to-256 demultiplexer and a 1-to-512 demultiplexer constructed from binary trees of 1-to-2 demultiplexers. 

 

Sequential Logic 

A register in Turing’s maze is a memory storage circuit with a data terminal and three control terminals: 

[ pic ] 

The Mandelbrot set circuit uses 16-bit registers, where each data terminal connects to the line of a bus shared by other registers and devices: 

[ pic ] 

To load a value from the register, the mouse visits the load terminal. It expresses the data storage tiles to the bus lines. 

To store a value into the register: 

The mouse visits the reset-and-store-enable terminal. It reverts the data storage tiles to red, and it connects them to the bus lines.  

The mouse expresses the value of another register or a device to the bus. This causes the mouse to enter some or all the register’s data terminals, changing data storage tiles to green.  

The mouse visits the store-disable terminal, which disconnects the data storage tiles from the bus lines. 

These steps repeated appear in the Mandelbrot set circuit. For example, to subtract two registers, the mouse visits the control lines of the registers and a 16-bit adder-subtractor, which all sharing the same bus, in a particular sequence: 

adder-subtractor - enable subtraction 

adder-subtractor - enable minuend store 

minuend register - load 

adder-subtractor - disable minuend store 

adder-subtractor - enable subtrahend store 

subtrahend register - load 

adder-subtractor - disable subtrahend store 

difference register - reset and enable store 

adder-subtractor - subtract and reset 

difference register - disable store 

There are no specific minuend, subtrahend, and difference registers. Rather, the names refer to any registers playing those roles during a subtraction. 

The sequence above is an example of a microprogram. The Mandelbrot set circuit encodes microprograms like this: 

[ pic ] 

The microprogram runs bottom-up. It asserts control lines through a buffer to avoid sharing conflicts: 

[ pic ] 

The animation below shows buffers driving a common control line. The buffers prevent separate line assertions from leaking into each other. 

[ pic ] 

For branching, a microprogram uses a circuit of the form: 

[ pic ] 

If a branch loops back to an earlier part of a microprogram, a diode installed along the return pathway ensures the mouse traverses the loop in the correct direction: 

[ pic ] 

 

 

Software 

This project includes a simulator and an emulator written in Java. The simulator loads an image of a Turing’s maze, where each pixel represents a tile with these colors: 

[ color table ] 

It runs the mouse from the entrance to the exit, and it saves an image of the final maze state.  

The emulator does the same, but it executes much faster. Before it runs the mouse from the entrance to the exit, it positions and orients the mouse on each red and green tile, and in each cardinal direction. It runs a simulation for those configurations that obtains a list of tiles the mouse turns red and a list of the tiles the mouse turns green until the mouse arrives at a red or green tile facing east or west. During each emulation cycle, it uses that precomputed table to jump the mouse from a source a red or green tile, while facing east or west, to a destination red or green tile, again facing east or west, while performing the expected tile color changes. If the mouse lands on a red tile, the emulator reverses its direction. 

To download the source code and the compiled binary, clone this repository. 

To run the simulator, navigate to the local repository directory, and execute the following command. 

[ simulator command ] 

To run the emulator, navigate to the local repository directory, and execute the following command. 

[ emulator command ] 

 

 

Mandelbrot Set 

The emulator performs this transformation: 

[ pic -> pic ] 

Click either image to view the full-resolution versions (10,149 x 12,540 pixels).  

The maze contains circuits that compute the Mandelbrot set and a matrix that displays the result: 

[ pic ] 

 

 

Here is a high-level overview: 

[ landscape pic ] 

Multiplier 

The multiplier operates on 16-bit fixed-point numbers, where the leading six bits represent a signed, two's complement integer, and the remaining ten bits represent a fraction, permitting values in the range [ -32.0, 31.9990234375 ]. It contains three registers: 

I – 5-bit loop index 

A – 16-bit multiplicand 

P – 32-bit product accessible as high and low 16-bit registers, PH and PL, respectively 

The multiplier contains three devices that perform the following operations. 

Move PH into PL 

Unsigned right-shift P by 1 

Left-shift P by 6 

The registers and the devices are labeled in the image below. 

[ pic ] 

It executes the following algorithm on multiplicands x and y.  

[ pseudocode ] 

At completion, PH contains the resultant product. 

Mandelbrot Evaluator 

The Mandelbrot evaluator is based on the optimized escape time algorithm described here. It contains eight registers: 

I – 7-bit loop index 

X0 – evaluation point x-coordinate 

Y0 – evaluation point y-coordinate  

X – escaping point x-coordinate 

Y – escaping point y-coordinate  

X2 – X squared 

Y2 – Y squared 

S – sum of squares 

The Mandelbrot evaluator also contains a device that left shifts by 1. The registers and the device are labeled in the image below. 

[ pic ] 

The following pseudocode explains how it works.  

[ pseudocode ] 

X0 and Y0 are initialized to the x- and y-coordinates of the evaluation point, respectively. 

The binary value 1111000000000000 represents –4.0.  

At completion, I contains the escape iterations. It maxes out at 64. 

Main 

The main microprogram plots a 512x512 pixel region of the Mandelbrot set in the range x E (-2.0,0.5) and y E (-1.25, 1.25). Since the set is horizontally symmetric within that region, the microprogram computes only the upper half. The display device reflects it to produce the entire image. 

The main microprogram contains four registers: 

J – 10-bit column index 

I – 10-bit row index 

X - evaluation point x-coordinate 

Y – evaluation point y-coordinate 

It executes the following algorithm. 

[ pseudocode ] 

The constants 1111101100000000 and 1111100000000000 represent –1.25 and –2.0, respectively. The value 5 corresponds to the interval between points: 2.5 / 512 = 0.0048828125. 

Display 

The main microprogram plots the Mandelbrot set on a 512x512 cell matrix. The image below depicts a 4x4 region. 

[ pic ] 

Each cell primarily consists of red tiles wired together to function as a large indicator. The AND gate in the lower-left corner of each cell drives the indicator. Each AND gate’s inputs are connected to row and column lines. And the express-and-reset terminals of all the AND gates are joined together. 

To turn a cell green, the mouse visits a row line, a column line, and the collective express-and-reset lines. Only the AND gate at the intersection of the row and column lines permits the mouse to reach an indicator.    

Demultiplexers drive the row and column lines: 

[ pic ] 

As mentioned, the circuit takes advantage of the Mandelbrot set’s horizontal symmetry. The row demultiplexer reflects the computed upper half into the lower half. 

 

 

Other Representations 

Turing’s maze can be modeled as a cellular automaton with sixteen cell states: 

[ pic of 16 tiles ] 

The rules that produce a new generation, which apply to the entire grid simultaneously, change only those few cells with the mouse in their neighborhood.  

It is also possible to model Turing’s maze as a turmite with forty-eight meta tiles: 

[ pic of 48 tiles ] 

Since the meta tiles include the proximate maze walls, the turmite needs only the current meta tile and its direction when deciding what to do. 

 

Universality 

A medium is Turing-complete if it can compute every Turing-computable function. Put another way, if it can replicate the functionality of all Turing machines. This section considers if Turing’s maze is such a medium. 

When a Turing machine runs, it allocates a finite amount of tape. But it is not possible to anticipate how much tape an arbitrary algorithm requires. As such, a Turing machine needs an unlimited supply. And importantly, the region of tape not containing the algorithm must be blank. This precludes the possibility that the algorithm is just an infinite lookup table that creates the illusion of computation. 

Turing’s maze can emulate tape cells and the head with constructs built around the red and green data storage tiles, like the registers described above. But it needs infinite cells, which means a maze of infinite width. In such a hypothetical maze, if the mouse traverses the entrance to the exit, then it still covers a finite distance. How far it voyages into the limitless tape depends on the algorithm. 

Consider the reverse: a Turing machine capable of simulating any Turing’s maze. Encoding an infinitely wide maze onto the tape would fill it up. That violates the rule mentioned above: the algorithm must initially fit on finite region of tape. However, it is possible to build a Turing machine that extends the maze on-demand. If the mouse reaches the maze’s edge, that machine would append more cell constructs. Such a machine would be universal because it can be initialized with a Turing’s maze representing any Turing-computable function. 

But expansion is not an inherent property of Turing’s maze. The mouse cannot dig out new passages. The only way to achieve the effect is to impose it externally. Consequently, Turing’s maze is best described as “weakly universal” rather than Turing-complete. Meaning, it can compute any algorithm, but some algorithms require a maze specified by repeating yet infinite information. 

Since Turing’s maze is universal, mazes exist for which it is not possible to determine if the mouse can traverse the entrance to the exit. This follows from the halting problem. 

 

Reversibility 

A Turing's maze is reversible if the mouse can change the color of a red or green tile at most once. Circuits with that constraint consist of one-time-use logic gates that lack reset paths. They can perform combinational logic, but not sequential logic. The red and green tiles within the gates store applied inputs. That enables the mouse to propagate inputs back to their origins in a reverse simulation. 

While reversible Turing’s maze does not permit sequential logic, its effect can be attained by repeating combinational logic. A hypothetical maze containing an infinite chain of combinational logic could perform any algorithm. This implies that reversible Turing’s maze is also “weakly universal”. 

 