Turing’s Maze 

Abstract 

Turing’s Maze is a discrete-event simulation of a mouse on a two-dimensional square lattice of black, gray, red, and green cells. As the mouse interacts with cells per a very simple set of rules, behaviors emerge particularly suited for emulating Boolean circuits. Consequently, it is possible to implement any algorithm as a maze traversed by the mouse.  

This article describes the rules of Turing’s Maze. It explains how to build gates, combinational logic, and sequential logic. And it demonstrates the mouse’s ability to compute with an implementation of the Mandelbrot set algorithm. 

Description 

Each simulation state consists of the mouse on a cell, facing a cardinal direction (north, east, south, or west). Per the rules described below, the mouse’s direction and the color of the cell it is on may change. Then it steps in its direction to an adjacent cell, transitioning the simulation to the next state. 

The mouse can move to cells of any color except for gray, which act as the walls of the maze. Passages primarily consist of black cells. Red and green cells operate something like traffic lights. 

The mouse enters a maze from a lone black cell in some column of the southernmost row. It exits to a lone black cell in some column of the northernmost row: 

[ pic ] 

The mouse traverses the maze by following the right-hand rule. That is, from the start, it keeps its right hand (or paw) in contact with the wall to its right, and it follows the wall around corners as it advances. However, if it encounters a four-way intersection, it plows straight through:   

[ pic ] 

If the mouse lands on a green cell while facing east or west, it proceeds as if the cell were black: 

[ pic ]   

If the mouse lands on a red cell while facing east or west, it reverses direction: 

[ pic ] 

If the mouse lands on a red or a green cell while facing south, the cell changes to or remains as red, and the mouse turns north: 

[ pic ] 

Finally, if the mouse lands on a red or green cell while facing north, the cell changes to or remains as green, and the mouse turns south: 

[ pic ] 

Formal Definition 

The simulator repeatedly performs the following three steps until the mouse exits the maze. 

The simulator potentially changes the current tile color and the mouse’s direction per the following pseudocode. 

[ pseudocode ] 

The simulator inspects the tiles immediately left, in front of, and right of the mouse. It uses the table below, where 1 indicates a wall (a gray tile) and 0 indicates a passage (a nongray tile), to potentially change the mouse’s direction to remain consistent with the right-hand rule modified to ignore four-way intersections. 

[ table ] 

The simulator moves the mouse in its direction to an adjacent tile.  

Circuits 

In the circuits described below, the mouse propagates logic one as it travels. Paths made of black tiles, separated by gray tiles, direct the mouse between components. They function as signal channels analogous to the wires of an electronic circuit. Four-way intersections act as non-connecting, crossing wires because the mouse disregards the right-hand rule when it encounters them. 

Red and green tiles operate as switching elements. Red represents a switch turned off, a disconnected channel that denies east-west signal propagation. And green represents a switch turned on, a connected channel that permits east-way signal propagation.  

The mouse turns a switch off by southwardly stepping onto a green tile. And it turns a switch on by northwardly stepping onto a red tile. 

Since a switch retains its state after the mouse steps away, red and green tiles also serve as data storage elements. In the circuits described below, red represents a stored logic zero and green represents a stored logic one.  

Note: It is possible to build inverted circuits, where the mouse propagates logic zero, or dual-rail circuits, where the mouse propagates logic zero or logic one depending on which of two paths the mouse takes. 

Logic Gates 

Unlike traditional logic gates, logic gates implemented in Turing’s maze store input Boolean values. The values are all initialized to logic zero. When the mouse visits an input terminal--where “visit” means it enters and it subsequentially returns from the terminal--it toggles the stored value corresponding to the input terminal to logic one. After setting the inputs in this way, the mouse enters an express-and-reset terminal, which evaluates the logical operation for the stored inputs. If the result is logic one, the mouse visits the output terminal, expressing the result to whatever is wired to the gate. Afterwards, the mouse resets the stored values to logic zeros, and it returns from the express-and-reset terminal. 

To make this clear, the image below depicts an AND gate with the input terminals, the output terminal, and the express-and-reset terminal labeled.  

[ pic ] 

The red tiles store the input values. When the mouse visits an input terminal, it switches a red tile to a green tile. When the mouse enters the express-and-reset terminal, it visits the output terminal only if the mouse switched both red tiles to green. Then it flips any green tiles back to red. And it returns from the express-and-reset terminal.    

The following animated examples depict logic gates attached to test harnesses of the form: 

[ pic ] 

Each harness uses red and green tiles to control which input terminals the mouse visits, and a red tile to capture the result of the logical operation for the given input values. 

[ gates ] 

The XOR gate demonstrates combinational logic. It consists of a NAND gate and an OR gate whose outputs feed into an AND gate. The XOR’s express-and-reset terminal directs the mouse to the NAND and OR gate’s express-and-reset terminals prior to the AND’s express-and-reset terminal. This ensures the logical operations are performed in the correct sequence. 

Like XOR, XNOR demonstrates combinational logic. It consists of a NOR gate and an AND gate whose outputs feed into an OR gate. As with XOR, XNOR’s express-and-reset terminal directs the mouse to evaluate the logical operations in the proper order. 

A single red or green tile can function as a transmission gate: 

[ pic ] 

The image below depicts part of the circuit that computes the Mandelbrot set. It shows stacks of transmission gates with common control lines that connect or disconnect devices to a 9-bit bus. 

[ pic ] 

A 1-to-2 demultiplexer steers the mouse from a data input terminal to one of two output terminals: 

[ pic ] 

Here are test harnesses exercising all possible input values: 

[ pic ] 

The Mandelbrot set circuit employs a 1-to-256 demultiplexer and a 1-to-512 demultiplexer constructed from a copious amount of 1-to-2 demultiplexers organized into binary trees. 

 

Sequential Logic 

A register in Turing’s maze is a memory storage circuit with a data terminal and three control terminals: 

[ pic ] 

The Mandelbrot set circuit uses 16-bit registers, where each data terminal connects to the line of a bus shared by other registers and devices: 

[ pic ] 

To load a value from the register, the mouse visits the load terminal. It expresses the values in the data storage tiles to the bus lines. 

To store a value into the register, the mouse visits the reset-and-store-enable terminal. It reverts the data storage tiles to red, and it connects them to the bus lines. Then the mouse expresses the value of another register or a device to the bus. This causes the mouse to enter some or all the register’s data terminals, changing the associated data storage tiles to green. Finally, the mouse visits the store-disable terminal, which disconnects the data storage tiles from the bus lines.  

The Mandelbrot set circuit contains several devices connected to the bus, including a 16-bit adder-subtractor. To subtract two registers, the mouse visits the control lines of the registers and the adder-subtractor in a particular sequence: 

adder-subtractor - enable subtraction 

adder-subtractor - enable minuend store 

minuend register - load 

adder-subtractor - disable minuend store 

adder-subtractor - enable subtrahend store 

subtrahend register - load 

adder-subtractor - disable subtrahend store 

difference register - reset and enable store 

adder-subtractor - subtract and reset 

difference register - disable store 

The Mandelbrot set circuits encodes microprograms like this using circuits of the form: 

[ pic ] 

The microprogram runs from the bottom to the top. It asserts control lines through a type of buffer to avoid conflicts induced by multiple calls to the same lines: 

[ pic ] 

The animation below shows buffers driving a common control line. The buffers prevent the invocations from leaking into each other. 

[ pic ] 

For branching, a microprogram uses a circuit of the form: 

[ pic ] 

If a branch loops back to an earlier part of a microprogram, a diode installed along the branch pathway ensures the mouse follows the loops in the correct direction: 

[ pic ] 

 

 

Software 

This project includes a simulator and an emulator written in Java. The simulator loads an image of a Turing’s maze, where each pixel represents a tile with these colors: 

[ color table ] 

It runs the mouse from the entrance to the exit, and it saves an image of the final maze state.  

The emulator does the same, but it executes much faster. Before it runs the mouse from the entrance to the exit, it positions the mouse on each red and green tile, and it orients the mouse in each cardinal direction. For each of those starting configurations, it runs a simulation that obtains a list of tiles the mouse turns red and a list of the tiles the mouse turns green until the mouse arrives at a red or green tile facing east or west. During each emulation cycle, it uses that precomputed table to jump the mouse from a source a red or green tile, while facing east or west, to a destination red or green tile, again facing east or west, while performing the expected tile color changes. If the mouse lands on a red tile, the emulator reverses its direction. 

To download the source code and the compiled binary, clone this repository. 

To run the simulator, navigate to the local repository directory, and execute the following command. 

[ simulator command ] 

To run the emulator, navigate to the local repository directory, and execute the following command. 

[ emulator command ] 

 

 

Mandelbrot Set 

The emulator performs this transformation: 

[ pic -> pic ] 

Click either image to view the full-resolution versions (10,149 x 12,540 pixels).  

 

 

 

The Mandelbrot set manifests on a 512x512 cell matrix. The image below depicts a 4x4 region. 

[ pic ] 

Each cell primarily consists of red tiles wired together to function as a large indicator. The AND gate in the lower-left corner of each cell drives the indicator. Each AND gate’s inputs are connected to row and column lines. And the express-and-reset terminals of all the AND gates are joined together. 

To turn a cell green, the mouse visits a row line, a column line, and the collective express-and-reset lines. Only the AND gate at the intersection of the row and column lines permits the mouse to reach an indicator.    

Demultiplexers drive the row and column lines: 

[ pic ] 

The maze takes advantage of the Mandelbrot set’s horizontal symmetry: it only computes the upper half. The row demultiplexer mirrors the computed region into the lower half. 

The row and column demultiplexers share a 9-bit bus. Red tiles, acting as transmission gates, establish or break the connection between a demultiplexer and the bus: 

[ pic ] 

From left to right, the control lines are: 

Connect row demultiplexer address lines to the bus 

Disconnect row demultiplexer address lines from the bus 

Connect column demultiplexer address lines to the bus 

Disconnect column demultiplexer address lines from the bus 

Connect common row and column demultiplexers data line to the bus 

Disconnect common row and column demultiplexers data line from the bus 

Express the AND gates, and reset the AND gates and demultiplexers 

The address lines configure the demultiplexers, establishing a pathway from the common data line (bit-0 of the bus) to the row and column lines.  

 

 

Other Representations 

It is possible to model Turing’s maze as a cellular automaton with sixteen cell states: 

[ pic of 16 tiles ] 

The rules that produce a new generation, which apply to the entire grid simultaneously, change only those few cells with the mouse in their neighborhood.  

It is also possible to model Turing’s maze as a turmite with forty-eight meta tiles: 

[ pic of 48 tiles ] 

Since the meta tiles include the proximate maze walls, the turmite needs only the current meta tile and its direction when deciding what to do. 

 

Universality 

A medium is Turing-complete if it can compute every Turing-computable function. Put another way, if it can replicate the functionality of all Turing machines. This section considers if Turing’s maze is such a medium. 

When a Turing machine runs, it allocates a finite amount of tape. But it is not possible to anticipate how much tape an arbitrary algorithm requires. As such, a Turing machine needs an unlimited supply. And importantly, the region of tape not containing the algorithm must be blank. This precludes the possibility that the algorithm is just an infinite lookup table that creates the illusion of computation. 

Turing’s maze can emulate tape cells and the head with constructs built around the red and green data storage tiles, like the registers described above. But it needs infinite cells, which means a maze of infinite width. In such a hypothetical maze, if the mouse traverses the entrance to the exit, then it still covers a finite distance. How far it voyages into the limitless tape depends on the algorithm. 

Consider the reverse: a Turing machine capable of simulating any Turing’s maze. Encoding an infinitely wide maze onto the tape would fill it up. That violates the rule mentioned above: the algorithm must initially fit on finite region of tape. However, it is possible to build a Turing machine that extends the maze on-demand. If the mouse reaches the maze’s edge, that machine would append more cell constructs. Such a machine would be universal because it can be initialized with a Turing’s maze representing any Turing-computable function. 

But expansion is not an inherent property of Turing’s maze. The mouse cannot dig out new passages. The only way to achieve the effect is to impose it externally. Consequently, Turing’s maze is best described as “weakly universal” rather than Turing-complete. Meaning, it can compute any algorithm, but some algorithms require a maze specified by repeating yet infinite information. 

Since Turing’s maze is universal, mazes exist for which it is not possible to determine if the mouse can traverse the entrance to the exit. This follows from the halting problem. 

 

Reversibility 

A Turing's maze is reversible if the mouse can change the color of a red or green tile at most once. Circuits with that constraint consist of one-time-use logic gates that lack reset paths. They can perform combinational logic, but not sequential logic. The red and green tiles within the gates store applied inputs. That enables the mouse to propagate inputs back to their origins in a reverse simulation. 

While reversible Turing’s maze does not permit sequential logic, its effect can be attained by repeating combinational logic. A hypothetical maze containing an infinite chain of combinational logic could perform any algorithm. This implies that reversible Turing’s maze is also “weakly universal”. 

 